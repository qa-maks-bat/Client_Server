QA Course by Vadim Ksendzov 
Group_30_QA

CLIENT_SERVER HOMEWORK

Name: Maksim Batrakou
Telegram: @maks_tbat 	 
Location: Minsk, Belarus
Environment: Windows 10, Notepad++

1. Прочитать про клиент-серверную архитектуру:

    * Клиент - это та программма, с которой работает пользователь (браузер, desktop-риложение) на персональном компьютере, смартфоне или другом девайсе.
    * Сервер - компьютер, на котором хранится само приложение, весь код, вся логика, все дополнительные материалы и справочники.
    * Клиент-серверная архитектура (КСА) может быть одно-, двух- и трёхуровневой, а также многоуровневой:
        + одноуровневая КСА (1-Tier): все прикладные программы рассредоточены по рабочим станциям, которые обращаются к общему серверу баз данных или общему файловому серверу. Никаких прикладных программ сервер при этом не исполняет, только предоставляет данные, двух- и трёхуровневой, а также многоуровневой;
        + двухуровневая КСА (2-Tier): прикладные программы сосредоточены на сервере приложений (Application Server), например, сервер 1С или сервер CRM, а в рабочих станциях находятся программы-клиенты, которые предоставляют для пользователей интерфейс для работы с приложениями на сервере:
            - fat client thin server (толстый клиент, тонкий сервер) - это, когда общие данные хранятся на сервере, а логика их обработки и бизнес данные хранятся на клиентской машине;
            - thin client fat server (тонкий клиент, толстый сервер) - это, когда не только данные, но и логика их обработки и бизнес-данные хранятся на сервере (прообраз облачных вычислений (Cloud Computing);
        + трёхуровневая КСА (3-Tier): сервер баз данных, файловый сервер и другие представляют собой отдельный уровень, результаты работы которого использует сервер приложений. Логика данных и бизнес-логика находятся на сервере приложений. Все обращения клиентов к базе данных происходят через промежуточное программное обеспечение (middleware), которое находится на сервере приложений;
        + многоуровневая КСА (N-Tier): несколько серверов приложений используют результаты работы друг друга, а также данные различных серверов баз данных, файловых серверов и других видов серверов.
        
2. Что такое HTTP и HTTPS:

    * HTTP (Hyper Text Transfer Protocol) - протокол передачи гипертекста, прикладной протокол передачи данных в сети, который используется для получения информации с веб-сайтов. 
    Протокол HTTP основан на использовании технологии "клиент-сервер":
         + клиент, отправляющий запрос, является инициатором соединения;
         + сервер, получающий запрос, выполняет его и отправляет клиенту результат.
    * HTTPS (Hyper Text Transfer Protocol Secure) - безопасный протокол передачи гипертекста, это расширение протокола HTTP, поддерживающее шифрование посредством криптографических протоколов SSL и TLS.
    * HTTP vs HTTPS:
         + HTTP использует порт 80, передаваемые данные не защищены;
         + HTTPS использует порт 443,обеспечивается конфиденциальность передаваемых данных путём их шифрования; 
         + HTTPS не является отдельным протоколом передачи данных, а представляет собой расширение протокола HTTP с надстройкой шифрования. Для реализации передачи данных посредством HTTPS на веб-сервере, обрабатывающем запросы от клиентов, должен быть установлен специальный SSL-сертификат. Наличие SSL-сертификата является одним из факторов ранжирования Google, поэтому переход на протокол HTTPS повышает позиции в поисковой выдаче Google.
    * SSL-сертификат — это цифровая подпись, которая позволяет обеспечить безопасное зашифрованное соединение между веб-сервером (сайтом) и веб-клиентом (браузером) посредством протокола HTTPS. SSL-сертификат особенно необходим ресурсам, которые работают с личными данными пользователей, платежными системами, конфиденциальной информацией. Шифрование таких данных обеспечит их защиту от перехвата третьими лицами, а также станет свидетельством заботы о пользователях.

3. HTTP методы:

    * GET - получение (возвращение) ресурса:
        + получение информации с сервера, не требует тела запроса;
        + получение данных с сервера (некоторые данные могут быть переданы в строке запроса URI, указывающие, например, условия поиска, диапазоны дат, или другую информацию, определяющую запрос): чтение без изменений, может запускать процесс, сообщения ответов сервера на выполнение метода могут кешироваться.
    * HEAD - получение ресурса:
        + как и метод GET, но без тела ответа (извлечение метаданных, проверка наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения), заголовки ответа могут кэшироваться.
    * POST - создание ресурса:
        + создает в базе новый объект, требует тело запроса с полями этого объекта;
        + передача пользовательских данных заданному ресурсу (передаваемые данные включаются в тело запроса), загрузка файлов на сервер, сообщение ответа сервера на выполнение метода не кешируется.
    * PUT - обновление ресурса:
        + полностью обновляет конкретный объект в базе данных;
        + применяется для загрузки содержимого запроса на указанный в запросе URI. Заменяет все текущие представления ресурса данными запроса. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус 201 (Created). Если же ресурс был изменён, то сервер возвращает 200 (Ok) или 204 (No Content). Сообщения ответов сервера не кэшируются.
    * PATCH - обновление ресурса:
        + аналогично PUT, обновляет определенный объект в базе данных, но обновляет только те поля, которые указаны в теле запроса;
        + аналогично PUT, но применяется только к фрагменту ресурса для частичного изменения ресурса;
    * DELETE - удаление ресурса:
        + удаляет объект из базы данных;
        + удаляет указанный ресурс.
    * TRACE - возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе;
    * CONNECT - преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.
    * OPTIONS - используется для получения сведений с сервера о параметрах соединения с ресурсом.
    
4. HTTP статус коды сервера:

    * 1xx: Informational (информационные):
        + 100 Continue (продолжай);
        + 102 Processing (идёт обработка).
    * 2xx: Success (успешно):
        + 200 OK (хорошо);
        + 201 Created (создано);
        + 202 Accepted (принято);
        + 203 Non-Authoritative Information (информация не авторитетна);
        + 204 No Content (нет содержимого).
    * 3xx: Redirection (перенаправление):
        + 300 Multiple Choices (множество выборов);
        + 301 Moved Permanently (перемещено навсегда);
        + 302 Moved Temporarily (перемещено временно) / Found (найдено);
        + 307 Temporary Redirect (временное перенаправление);
        + 308 Permanent Redirect (постоянное перенаправление).
    * 4xx: Client Error (ошибка клиента):
        + 400 Bad Request (неправильный, некорректный запрос);
        + 401 Unauthorized (не авторизован (не представился));
        + 402 Payment Required (необходима оплата);
        + 403 Forbidden (запрещено (не уполномочен));
        + 404 Not Found (не найдено);
        + 405 Method Not Allowed (метод не поддерживается);
        + 406 Not Acceptable (неприемлемо);
        + 408 Request Timeout (истекло время ожидания);
        + 410 Gone (удалён);
        + 417 Expectation Failed (ожидание не удалось);
        + 418 I’m a teapot (я — чайник).
    * 5xx: Server Error (ошибка сервера):
        + 500 Internal Server Error (внутренняя ошибка сервера);
        + 501 Not Implemented (не реализовано);
        + 502 Bad Gateway (плохой, ошибочный шлюз);
        + 503 Service Unavailable (сервис недоступен);
        + 504 Gateway Timeout (шлюз не отвечает);
        + 505 HTTP Version Not Supported (версия HTTP не поддерживается);
        + 520 Unknown Error (неизвестная ошибк»);
        + 521 Web Server Is Down (веб-сервер не работает);
        + 522 Connection Timed Out (соединение не отвечает);
        + 523 Origin Is Unreachable (источник недоступен);
        + 524 A Timeout Occurred (время ожидания истекло);
        + 526 Invalid SSL Certificate (недействительный сертификат SSL).

5. Что такое ядро браузера:
    
    * Браузер = оболочка + ядро (браузерный движок).
    * Браузерный движок (layout engine) - представляет собой программу, преобразующую содержимое веб-страниц (файлы HTML, XML, цифровые изображения и т. д.) и информацию о форматировании (в форматах CSS, XSL и т. д.) в интерактивное изображение форматированного содержимого на экране, т.е. это программа, которая отображает контент на основе языка разметки.

6. Какие браузеры какие ядра используют:

    * Blink - движок браузера Chromium, Google Chrome (с 28 версии), Microsoft Edge (с 79 версии), Opera (c 15 версии) и Vivaldi. Он является ответвлением WebKit.
    * Gecko — открытый движок проекта Mozilla. Используется в большом числе программ, основанных на коде Mozilla (в браузере Firefox, почтовом клиенте Thunderbird, наборе программ SeaMonkey).
    * WebKit — движок для браузера Apple Safari, включенного в операционную систему Mac OS X, и браузера Google Chrome (до 2013 года).
    * KHTML — разработан в рамках проекта KDE, используется в браузере Konqueror и послужил основой для WebKit.

7. Что такое API:

    * API (Application Programming Interface, интерфейс программирования приложений, программный интерфейс приложения) - это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».
    * Контракт включает в себя:
        + саму операцию, которую мы можем выполнить;
        + данные, которые поступают на вход;
        + данные, которые оказываются на выходе (контент данных или сообщение об ошибке).
    * Вызвать API можно как напрямую, так и косвенно:
        + система вызывает функции внутри себя;
        + система вызывает метод другой системы;
        + человек вызывает метод;
        + автотесты дергают методы;
        + пользователь работает с GUI.
    * Когда говорят про API с тестировщиком, обсуждают два варианта:
        + автотесты на уровне API (умение автоматизировать);
        + интеграцию между двумя разными системами (обычно SOAP или REST, то есть работу в SOAP UI или Postman).
        
    * API - это составляющая часть сервера, которая получает запросы и отправляет ответы. Каждый раз, когда пользователь посещает какую-либо страницу в сети, он взаимодействует с API удалённого сервера.
    Например, через браузер можно напрямую обратиться к API GitHub (https://api.github.com/users/qa-maks-bat), причём без маркера доступа, и получить ответ в формате JSON, который вполне можно вставлять в код. Из получаемого текста достаточно просто извлечь данные, чтобы использовать их по своему усмотрению.
    При внедрении в код разработчиком сторонней библиотеки, она становится частью всего приложения. Будучи самостоятельным фрагментом ПО, библиотека будет иметь некий API, который позволит ей взаимодействовать с остальным кодом приложения.
    В объектно-ориентированном проектировании код представлен в виде совокупности объектов. В приложении таких объектов, взаимодействующих между собой,  могут быть сотни. У каждого из них есть свой API - набор публичных свойств и методов для взаимодействия с другими объектами в приложении.
    Допустим, вы решили подключить сервис сайта поиска адресов к своему интернет-магазинчику, чтобы пользователь легко ввел адрес доставки. Вы подключаетесь к сайту подсказок по API. И теперь, когда пользователь начинает вводить адрес на вашем сайте, он видит подсказки из сайта поиска адресов.
    Как это получается:
        -> Пользователь вводит букву на вашем сайте ->
        -> Ваш сайт отправляет запрос на сайт поиска адресов по API ->
        -> Сайт поиска адресов возвращает ответ ->
        -> Ваш сайт его обрабатывает и отображает результат пользователю!
    И так происходит на каждый введенный символ. Пользователь не видит этого взаимодействия, но оно есть.

8. Что такое эндпоинты:

    * Endpoint (эндпоинт) - это адрес, на который отправляются сообщения, т.е. адрес самого запроса. 
    * Приложения используют API для взаимодействия со сторонними приложениями и своими пользователями. Чтобы связаться с API, нужно отправить ему запрос. Для корректной обработки запроса клиент должен предоставить URL (унифицированный определитель местонахождения ресурса), метод запроса (HTTP method), и в зависимости от метода добавить headers (заголовки), body (тело), parameters (параметры запроса).

9. URL (URI, URL, URN):

    * URL (Uniform Resource Locator, унифицированный определитель местонахождения ресурса) - исторически возник самым первым из понятий и закрепился как синоним термина веб-адрес.
      URL определяет местонахождение ресурса в сети и способ его (ресурса) извлечения. Это позволяет нам полностью узнать: как, кому и где можно достать требуемый ресурс, вводя понятия схемы, данных авторизации и местонахождения.
      URL появился в 1990 году, а URI в 1994 году и назывались универсальными. Эти 4 года URL определялся как местонахождение файла (ведь ресурс это не сайт, это может быть любой файл)? таким образом URL это URI.
      
    * URN (Uniform Resource Name, унифицированное имя ресурса) - неизменяемая последовательность символов, определяющая только имя некоторого ресурса. Смысл URN в том, что им единоразово и уникально именуется какая-либо сущность в рамках конкретного пространства имен (контекста).
      URN включает в себя название пространства имён и идентификатора в этом пространстве.
      URN возникло из-за существенных недостатков системы URL, и URL не может быть URN и наоборот. При этом URN это URI, который только идентифицирует ресурс в определённом пространстве имён (и, соответственно, в определённом контексте), но не указывает его местонахождения.
      
    * URI (Uniform Resource Identifier, унифицированный идентификатор ресурса) -  это обобщенное понятие (множество) идентификации ресурса.
      URI должен идентифицировать ресурс как в определённом пространстве имён (URN), так и его местоположение (URL), включающее в нашем случае как URL, так и URN, как по отдельности, так и совместно, таким образом:
        + URL = URI (полная идентификация файла: место (cайт (сервер), rаталоги, подкаталоги, имя файла, расширение);
        + URN = URI (место (cайт (сервер);
        + URI = URL + URN (название пространства имён и идентификатора в этом пространстве):
            - URI, URL --> http://handynotes.ru/2009/09/uri-url-urn.html
            - URL, URI --> http://handynotes.ru ........................
            - URN, URI --> ..................../2009/09/uri-url-urn.html, иначе можно записать:
                                   %systemroot%/2009/09/uri-url-urn.html

10. Идемпотентные HTTP методы:

    * Идемпотентные HTTP методы (GET, HEAD, OPTIONS, PUT, DELETE, TRACE) - при повторном их выполнении результаты будут ожидаемо одинаковыми.
    * Неидемпотентные HTTP методы (POST, PATCH) - при повторном выполнении результаты будут разными. Если, например, отправить POST-запрос на создание элемента несколько раз подряд, то он может создать несколько элементов с одинаковыми данными.

11. Безопасные HTTP методы: 

    * Безопасные HTTP методы (GET, HEAD, OPTIONS, TRACE) - не изменяют данные, их можно выполнять в любой последовательности. 

12. Иденфикация, Аутентификация, Авторизация

13. Что такое IP

14. Что такое октаты в DNS

15. Что такое порт, сколько портов у Linux сервера

16. Уровни OSI

17. Хедеры http запросов
